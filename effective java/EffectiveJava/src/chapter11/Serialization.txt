序列化
	将对象编码成字节流，并从字节流编码中重新构建对象
	
74、谨慎地实现Serializable接口
	1）一旦一个实现了Serializable接口的类被发布，就大大降低了改变这个类的实现的灵活性
	应该设计一种高质量的序列化形式，并且在很长时间内都愿意使用这种形式
	2）增加了出现bug和安全漏洞的可能性。反序列化也是一个“隐藏的构造器”，需要保证一定的约束
	3）随着类发行新的版本，相关的测试负担也增加了。
	为了继承而设计的类尽可能少地去实现Serializable，用户的接口也是
	内部类不应该实现Serializable，静态成员类可以实现
	
75、考虑使用自定义的序列化形式
	一个类实现了Serializable接口，并且使用了默认的序列化形式，将永远无法摆脱那个应该丢弃的实现
	defaultWriteObject被调用时，每一个未被标记为transient的实例域都会被序列化
	defaultReadObject会把transient的实例域初始化为默认值，所以如果默认值不被接受，则要进行修改
	如果在读取整个对象状态的任何其他方法上强制任何同步，则也必须在对象序列化上强制这种同步
	不管哪种序列化形式，都要声明一个显示的序列版本UID，避免不兼容
	
76、保护性地编写readObject方法
	readObject相当于一个共有的构造器，无论给它传递什么样的字节流，它都必须产生一个有效的实例
	下面几条指导方针，有助于编写更加健壮的readObject方法
		对于对象引用域必须保持为私有的类，要保护性地卡背这些域中的每个对象。不可变类的可变组件就属于这一类
		对于任何约束，如果检查失败，则抛出一个InvalidObjectException，检查在所有的保护性拷贝之后
		如果整个对象图在被反序列化之后必须进行验证，应该用ObjectInputValidation接口
		无论是直接还是间接方法，都不要调用类中任何可被覆盖的方法
		
77、对于ReadResolve，枚举类型优先于实例控制
	readResolve的可访问性很重要
	尽可能使用枚举代替实例控制(单例)，如果做不到，同时又需要一个即可序列化优势实例控制的类，
		需要提供一个readResovler方法，并确保所有实例域是基本类型，或者是transient的
		
78、考虑用序列化代理代替序列化实例
	在需要序列化的类内部创建一个私有嵌套类，它来代理外围类的序列化和反序列化
	当需要编写一个不能被客户端扩展的类上编写readObject或者writeObject方法时，使用序列化代理模式