异常
	充分发挥异常的优点可以提高程序的可读性、可靠性和可维护性，如果使用不当也会带来负面影响
	
57、只针对异常的情况才使用异常
	不用异常来处理数组的遍历(ArrayClimb.java)
		异常机制的设计是用于不正常的情况，很少有jvm会优化它
		把代码放在try-catch块反而阻止了现代jvm可能执行的优化
		对数组进行遍历的标准模式并不会导致冗余的检查
	异常应该只用于异常的情况，永远不该用于正常的控制流
	
58、对可恢复的情况使用受检异常，对编程错误使用运行时异常
	Java中的三种可抛出结构：受检的异常(checked exception)、运行时异常(run-time exception)、错误(eror)
	如果期望调用者能够适当地恢复，应该使用受检的异常
	
59、避免不必要地使用受检的异常
	受检的异常强迫程序员处理异常的条件，大大增强了可靠性
	把受检的异常变为未受检的异常，把这个抛出异常的方法分为两个方法，其中一个返回boolean，表明是否抛出异常
	
60、优先使用标准的异常
	为了代码重用，优先使用标准的异常
	IllegalArgumentException	非null的参数值不正确
	IllegalStateException		对于方法调用而言，对象状态不合适
	NullPointerException		在禁止使用null的情况下参数值为null
	IndexOutOfBoundsException	下标参数值越界
	ConCurrentModificationException在禁止并发修改的情况下，检测到对象的并发修改
	UnsupportedOperationException	对象不支持用户请求的方法
	
61、抛出与抽象相对应的异常
	如果方法抛出的异常和它所执行的任务没有明显的联系，这种情形将会使人不知所措
	为了避免这个问题，更高层的实现应该捕获低层的异常，同时抛出可以按照高层抽象进行解释的异常
		代码如下：
		try {
			... // Use lower-level abstraction to do our bidding
		} catch (LowerLevelException cause) {
			throw new HigherLevelException(cause);
		}
	
62、每个方法抛出的异常都要有文档
	在方法的声明中用@throws标记出可能出现的受检的异常

63、在细节消息中包含能捕获失败的信息
	为了捕获失败，异常的细节信息应该包含所有对该异常有贡献的参数和域的值
	
64、努力使失败保持原子性
	失败的方法调用应该使对象保持在被调用之前的状态，即失败原子性
	实现方法：
		设计一个不可变的对象
		调整计算处理过程的顺序，使得任何可能会失败的计算部分都在对象状态被修改之前发生
		编写一段恢复代码，由它来拦截操作过程中发生的失败，以及使对象回滚到开始前的状态
		在对象的一份临时拷贝上执行操作，当操作完成后，再用临时拷贝中的结果代替对象的内容
	一般作为方法规范的一部分，产生的任何异常都应该然对象保持在该方法调用之前的状态，如果违反这条规则，API文档应该清楚地指明对象将处于什么样的状态
	
65、不要忽视异常
	当API的一个方法将抛出某个异常时，应该对出现异常做出自己的反应，不能什么都不做