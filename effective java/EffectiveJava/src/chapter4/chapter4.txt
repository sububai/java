类和接口

13、使类和成员的可访问性最小
	尽可能地使每个类和成员不被外界访问
	实例域不能是公有的
	长度非零的数组总是可变的，不管是不是final类型，不能设为公有域，或者提供指向这个域的公有方法
		，可以提供一个公有的不可变列表(Collections.unmodifiableList())，或者提供一个返回克隆数组的公有方法
		
14、在公有类中使用访问方法而不是公有域
	有时候会把域暴露在包内
	
15、使可变性最小化
	为了使类成为不可变，需要遵守以下五条规则：
		不要提供任何会修改对象状态的方法
		保证类不会被扩展，可以用final修饰类或者让类的所有构造器是私有的或包级私有的，然后用静态工厂方法创建对象
		使所有域都是final的
		使所有域都是私有的
		确保对于任何可变组件的互斥访问
	不可变对象的优点：
		多线程安全
		不需要复制操作
		提供了大量的构件
	缺点：对于每个不同的值都需要一个单独的对象

16、复合优先于继承:composition over inheritance
	Decorator模式：装饰一个类来增加功能
	包装类不能用于回调框架
	只有当子类真正是超类的子类型(subtype)时才适合用继承，因为继承打破了封装，否则应该复合
	
17、要么为继承而设计，并提供文档说明，要么就禁止继承
	如果是为继承而设计，需要设计好每一个公有的或者受保护的方法
	必须在发布类之前先编写子类进行测试
	构造器决不能调用可覆盖的方法，因为父类构造器先执行，会调用子类中被覆盖的方法
	如果实现了Cloneable和Serializable接口，需要重写clon和readObject，而且都不可以调用可被覆盖的方法
	如果既不是为继承而设计，也不是不可继承的类，应该消除类的自用性(self-use)，可以采用私有的辅助方法来消除自用性
	
18、接口优于抽象类
	现有的类可以很容易被更新，以实现新的接口
	接口是定义mixin(混合类型)的理想选择
	接口允许我们构造非层次结构的类型框架
	通常有一个实现了接口中最基本的功能的抽象类骨架，可以帮助实现接口

19、接口只用于定义类型
	常量接口：没有方法，只包含静态的final域，每个域都导出一个常量，使用这些常量的类实现此接口
		常量接口是对接口的不良使用，可以工具类来代替常量接口，然后静态导入工具类
	
20、类层次优先于标签类
	标签类过于冗长，容易出错，并且效率低下
	
21、用函数对象表示策略
	函数指针的主要用途就是实现策略(Strategy)模式
	在Java中，声明一个接口来表示该策略，并且为每个策略声明一个实现该接口的类
		，如果具体策略只被使用一次时，通常使用匿名类，当具体策略是设计用来重复使用时，用私有的静态成员类表示，通过公有的静态final域导出
	
22、优先考虑静态成员类
	嵌套类nested class是指被定义在另一个类中，为外围类提供服务。
	静态成员类static member class：作为公有的辅助类
	非静态成员类nonstatic member class：作为Adapter等和类实例有关的辅助类
	匿名类anonymous class：动态地创建函数对象、创建过程对象、在静态工厂方法内部
	局部类local class：在任何可以创建局部变量的地方都可以创建局部类