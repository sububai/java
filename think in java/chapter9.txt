违例差错控制：形式错误的代码不会运行，所以编译期间的错误会被发现，但还有在运行期的错误需要违例控制

1、违例处理过程：
  1、创建违例对象，在内存堆，new
  2、停止当前执行路径，释放违例对象的句柄
  3、违例控制机制执行违例控制器(catch块)，要么尝试另一条执行路径，要么简单地继续

2、违例的捕获
  警戒区：特殊的代码区域，又可能产生违例，并在后面跟随用于控制那些违例的代码
  try {
    //可能产生违例的代码
  } catch(Type1 id1) {
    //处理type1的违例
  } catch(Type2 id2) {
    //处理type2的违例
  }...

  违例控制有两种：
    中断：错误非常关键，没有办法返回违例发生的地方
    恢复:纠正当前的状况，然后取得出错的方法，假定下一次会成功执行

  违例规范
    方法声明时应说明可能产生什么类型的违例
    void f() throws tooBig, tooSmall｛ //...

3、Throwable：对可以作为违例的所有东西进行了描述
    Error：编译期和系统错误，一般不捕获
    Exception：从任何标准Java库的类方法中"掷"出的基本类型
      RuntimeException默认会自动得到处理，一般不必专门捕获

4、创建自己的违例

5、违例的限制：覆盖一个方法时，只能产生已在方法的基础类版本中定义的违例
    1、子类的构造器必须抛出父类构造器中抛出的违例，可以添加新的违例
    2、正常的方法符合父类：抛出父类版本中定义的若干(0-n)违例

6、用finally清除
  finally块：无论违例是否在try块中发生，都会执行的操作

7、构建器：在构建器中的违例清除需要正确处理，可能需要分多种情况，不能都在finally中清除

8、违例匹配：衍生类对象可以和基础类的控制器匹配
  违例准则：
  1、解决问题并在此调用造成违例的方法
  2、平息事态的发展，不重新尝试方法的前提下继续
  3、计算另一些结果，而不是希望方法产生的结果
  4、尽可能解决问题，将相同或不同的违例重新抛出到更高级的环境
  5、中止程序执行
  6、简化编码
  7、是自己的库和程序变得更加安全
