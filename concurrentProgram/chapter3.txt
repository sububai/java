对象的共享

1、可见性
  在没有同步的情况下，编译器、处理器以及运行时都可能对操作的执行顺序进行一些意想不到的调整

  1.1、失效数据：数据在多个线程之间共享，如果没有正确同步，可能读到失效的数据

  1.2、非原子的64位操作
    除了非volatile类型的long和double变量,读取到失效值是之前某个线程中设置的，而不是随机值
    原因：Java内存模型要求，变量的读取和写入操作必须是原子操作，jvm允许对64位的读写操作分解成两个32位的操作

  1.3、加锁和可见性
    加锁不仅局限于互斥行为，还包括内存可见性，确保所有线程可以看到共享变量的最新值。

  1.4、Volatile变量
    确保变量的更新操作通知到其他线程
    通常用作某个操作完成、中断或者状态的标志
    是一种稍弱的同步机制，因为volatile只保证了可见性，而加锁既保证了可见性也保证了原子性

2、发布和逸出：
  发布Publish：使对象可以被当前作用域之外的代码使用
  逸出Escape：不应该发布的对象被发布
  使用工厂方法防止this引用逸出

3、线程封闭
  仅在单线程内访问数据，就不需要同步
  如swing，jdbc的Connection对象：一个对象对应一个线程
  3.1、Ad-hoc：由程序维护线程封闭性，volatile类型的公共变量
  3.2、栈封闭：局部变量
  3.3、ThreadLoal：每个线程都会保存一个对象的副本，所以线程实际操作的是此线程中的副本
  3.4、不变性：不可变对象一定是线程安全的
    满足以下条件，对象才是不可变的：
      对象创建以后状态不能修改
      对象的所有域都是final类型
      对象是正确创建的（this引用没有逸出
    final域：可以保证一定的不变性，即被声明的域为不变的，但不包括域的子域
  3.5、安全发布
    不正确的发布会导致对象被破坏
    要正确发布一个对象，对象的引用和对象的状态必须同时对其他线程可见。可以通过一下方式安全发布
      a、在静态初始化函数中初始化一个对象引用
      b、将对象的引用保存到volatile类型的域或者AtomicReference对象中
      c、将对象的引用保存到某个正确构造对象的final中
      d、将对象的引用保存到一个由锁保护的域汇总
    对象的发布需求取决于它的可变性
      不可变对象可以通过任意机制来发布
      事实不可变对象必须通过安全方式来发布
      可变对象必须通过安全方式来发布，并且必须是线程安全的或者有一个锁保护起来

    总结：使用对象的策略
      线程封闭：对象只能由一个线程拥有
      只读共享：没有额外同步的情况下，共享的只读对象可以由多个线程并发访问，但任何线程都不可以修改它
                共享的只读对象包括不可变对象和事实不可变对象
      线程安全共享：对象在其内部实现同步，多个线程可以通过对象的公有接口进行访问而不需要进一步的同步
      保护对象：对象只能通过持有特定的锁来访问。保护对象包括在其他线程安全对象中的对象，以及已发布的并且由某个特定锁保护的对象
