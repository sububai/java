避免活跃性危险(死锁为主

1、死锁
	锁顺序死锁：线程以不同的顺序获得相同的锁，如LeftRightDeadlock.java
	动态的锁顺序死锁，这两种死锁都可以采用固定锁顺序来避免死锁
	在协作对象之间发生的死锁，持有锁的线程在调用其它方法时可能出现死锁
	开放调用，调用一个方法不需要持有锁，可以解决协作对象之间可能的死锁，意味着如果一个方法不是必须是原子操作，
		则可以分开操作，确定每个操作是否需要锁
2、死锁的避免和诊断
	定时锁，Lock的tryLock功能，显式锁，可以在超过一定时间还没有获得锁时放弃
	通过JVM的线程转储分析死锁，包括运行中的各个线程的栈追踪信息
其他活跃性危险
	饥饿：线程无法访问他所需要的资源而不能继续执行。线程优先级和平台有关，所以要避免使用，增强平台无关性
	糟糕的响应性：GUI应用中后台程序太多导致前台程序响应性降低。不良的锁管理也会导致，
		如某个线程长时间持有一个锁，而其他线程想要访问。
	活锁：线程或不断重复执行相同的操作，而且总会失败。通常发生在处理事务上，事务执行失败导致回滚，然后又执行失败。
		这就是过度的错误恢复代码，错把不可修复的错误当成可修复的。解决方法是在重试机制中引入随机性，不让每次的重试操作都相同

小结：活跃性危险中最常见的是锁顺序死锁，所以获得锁的顺序尽量固定，或者采用开放调用。